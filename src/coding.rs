// ttxi - coding.rs
// Copyright (c) 2024 Alistair Buxton <a.j.buxton@gmail.com>
// GPLv3


pub fn hamming8_decode(x : u8) -> u8 {
    const HAMMING8_DEC: [u8; 256] = [
        0x1, 0xf, 0x1, 0x1, 0xf, 0x0, 0x1, 0xf, 0xf, 0x2, 0x1, 0xf, 0xa, 0xf, 0xf, 0x7,
        0xf, 0x0, 0x1, 0xf, 0x0, 0x0, 0xf, 0x0, 0x6, 0xf, 0xf, 0xb, 0xf, 0x0, 0x3, 0xf,
        0xf, 0xc, 0x1, 0xf, 0x4, 0xf, 0xf, 0x7, 0x6, 0xf, 0xf, 0x7, 0xf, 0x7, 0x7, 0x7,
        0x6, 0xf, 0xf, 0x5, 0xf, 0x0, 0xd, 0xf, 0x6, 0x6, 0x6, 0xf, 0x6, 0xf, 0xf, 0x7,
        0xf, 0x2, 0x1, 0xf, 0x4, 0xf, 0xf, 0x9, 0x2, 0x2, 0xf, 0x2, 0xf, 0x2, 0x3, 0xf,
        0x8, 0xf, 0xf, 0x5, 0xf, 0x0, 0x3, 0xf, 0xf, 0x2, 0x3, 0xf, 0x3, 0xf, 0x3, 0x3,
        0x4, 0xf, 0xf, 0x5, 0x4, 0x4, 0x4, 0xf, 0xf, 0x2, 0xf, 0xf, 0x4, 0xf, 0xf, 0x7,
        0xf, 0x5, 0x5, 0x5, 0x4, 0xf, 0xf, 0x5, 0x6, 0xf, 0xf, 0x5, 0xf, 0xe, 0x3, 0xf,
        0xf, 0xc, 0x1, 0xf, 0xa, 0xf, 0xf, 0x9, 0xa, 0xf, 0xf, 0xb, 0xa, 0xa, 0xa, 0xf,
        0x8, 0xf, 0xf, 0xb, 0xf, 0x0, 0xd, 0xf, 0xf, 0xb, 0xb, 0xb, 0xa, 0xf, 0xf, 0xb,
        0xc, 0xc, 0xf, 0xc, 0xf, 0xc, 0xd, 0xf, 0xf, 0xc, 0xf, 0xf, 0xa, 0xf, 0xf, 0x7,
        0xf, 0xc, 0xd, 0xf, 0xd, 0xf, 0xd, 0xd, 0x6, 0xf, 0xf, 0xb, 0xf, 0xe, 0xd, 0xf,
        0x8, 0xf, 0xf, 0x9, 0xf, 0x9, 0x9, 0x9, 0xf, 0x2, 0xf, 0xf, 0xa, 0xf, 0xf, 0x9,
        0x8, 0x8, 0x8, 0xf, 0x8, 0xf, 0xf, 0x9, 0x8, 0xf, 0xf, 0xb, 0xf, 0xe, 0x3, 0xf,
        0xf, 0xc, 0xf, 0xf, 0x4, 0xf, 0xf, 0x9, 0xf, 0xf, 0xf, 0xf, 0xf, 0xe, 0xf, 0xf,
        0x8, 0xf, 0xf, 0x5, 0xf, 0xe, 0xd, 0xf, 0xf, 0xe, 0xf, 0xf, 0xe, 0xe, 0xf, 0xe,
    ];
    HAMMING8_DEC[x as usize]
}


pub fn hamming16_decode(buf : &[u8]) -> u8 {
    return (hamming8_decode(buf[0])) | (hamming8_decode(buf[1]) << 4);
}


pub fn mrag(buffer : &[u8]) -> (u8, u8) {
    let m = hamming16_decode(buffer);
    return (m & 0x7, m >> 3);
}

pub fn control_bits(buffer : &[u8]) -> u16 {
    let a : u16 = hamming16_decode(&buffer[..2]) as u16;
    let b : u16 = hamming16_decode(&buffer[2..4]) as u16;
    let c : u16 = hamming16_decode(&buffer[4..6]) as u16;
    (a >> 7) | ((b >> 5) & 0x6) | (c << 3)
}


pub fn ascii_to_u8(c : u8) -> u8 {
    match c {
        b'0'..=b'9' => c - b'0',
        b'A'..=b'F' => c + 0xa - b'A',
        b'a'..=b'f' => c + 0xa - b'a',
        _ => panic!(),
    }
}

pub fn u8_to_ascii(c : u8) -> u8 {
    match c {
        0..=9 => b'0' + c,
        0xa..=0xf => b'A' - 0xa + c,
        _ => panic!(),
    }
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_u8_to_ascii() {

        let result = u8_to_ascii(0xf);
        assert_eq!(result, b'F');
    }

    #[test]
    fn test_ascii_to_u8() {
        let result = ascii_to_u8(b'f');
        assert_eq!(result, 0xf);
    }
}